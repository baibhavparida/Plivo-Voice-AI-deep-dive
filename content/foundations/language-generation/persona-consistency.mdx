---
title: "Persona Consistency for Voice AI"
description: "Complete guide to maintaining persona consistency in voice AI systems, covering persona definition, consistency mechanisms, brand voice guidelines, and personality trait implementation."
category: "foundations"
tags:
  - persona
  - voice-design
  - brand-voice
  - consistency
  - voice-ai
relatedTopics:
  - response-templates
  - dynamic-generation
  - ssml
lastUpdated: "2026-01-21"
difficulty: intermediate
---

# Persona Consistency for Voice AI

Persona consistency ensures your voice AI maintains a coherent identity across all interactions. A well-defined persona creates trust, improves user experience, and reinforces brand identity throughout every conversation.

## Defining Voice Personas

A voice persona encompasses the complete identity of your AI assistant, including personality, communication style, and behavioral patterns.

### Persona Framework

```python
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from enum import Enum

class PersonalityDimension(Enum):
    """Big Five personality dimensions adapted for voice AI"""
    WARMTH = "warmth"              # Cold to Warm
    FORMALITY = "formality"        # Casual to Formal
    ENERGY = "energy"              # Calm to Energetic
    CONFIDENCE = "confidence"      # Humble to Assertive
    HUMOR = "humor"                # Serious to Playful

@dataclass
class VoiceCharacteristics:
    """TTS voice configuration"""
    voice_id: str
    speaking_rate: float = 1.0     # 0.5 to 2.0
    pitch: float = 0.0             # -20 to +20 semitones
    volume_gain_db: float = 0.0    # -6 to +6 dB
    emphasis_style: str = "moderate"  # none, moderate, strong

@dataclass
class CommunicationStyle:
    """Communication preferences"""
    sentence_length: str = "medium"     # short, medium, long
    vocabulary_level: str = "standard"  # simple, standard, sophisticated
    uses_contractions: bool = True
    uses_filler_words: bool = False
    asks_clarifying_questions: bool = True
    confirms_understanding: bool = True
    active_listening_phrases: List[str] = field(default_factory=list)

@dataclass
class PersonaBehavior:
    """Behavioral patterns"""
    greeting_style: str = "friendly"
    farewell_style: str = "warm"
    error_handling_style: str = "apologetic"
    escalation_style: str = "seamless"
    wait_time_handling: str = "engaging"

@dataclass
class VoicePersona:
    """Complete voice persona definition"""

    # Identity
    name: str
    role: str
    description: str

    # Personality (0.0 to 1.0 for each dimension)
    personality: Dict[PersonalityDimension, float] = field(default_factory=dict)

    # Voice
    voice: VoiceCharacteristics = None

    # Communication
    communication: CommunicationStyle = None

    # Behavior
    behavior: PersonaBehavior = None

    # Language
    preferred_phrases: List[str] = field(default_factory=list)
    avoided_phrases: List[str] = field(default_factory=list)
    domain_vocabulary: Dict[str, str] = field(default_factory=dict)

    # Constraints
    topics_allowed: List[str] = field(default_factory=list)
    topics_forbidden: List[str] = field(default_factory=list)

    def get_personality_description(self) -> str:
        """Generate natural language personality description"""
        descriptions = []

        warmth = self.personality.get(PersonalityDimension.WARMTH, 0.5)
        if warmth > 0.7:
            descriptions.append("warm and friendly")
        elif warmth < 0.3:
            descriptions.append("professional and efficient")

        formality = self.personality.get(PersonalityDimension.FORMALITY, 0.5)
        if formality > 0.7:
            descriptions.append("formal and polished")
        elif formality < 0.3:
            descriptions.append("casual and relaxed")

        energy = self.personality.get(PersonalityDimension.ENERGY, 0.5)
        if energy > 0.7:
            descriptions.append("energetic and enthusiastic")
        elif energy < 0.3:
            descriptions.append("calm and measured")

        return ", ".join(descriptions) if descriptions else "balanced and adaptable"
```

### Persona Templates

```python
# Pre-defined persona templates
PERSONA_TEMPLATES = {
    "professional_assistant": VoicePersona(
        name="Alex",
        role="Professional Business Assistant",
        description="A polished, efficient assistant for business contexts",
        personality={
            PersonalityDimension.WARMTH: 0.6,
            PersonalityDimension.FORMALITY: 0.7,
            PersonalityDimension.ENERGY: 0.5,
            PersonalityDimension.CONFIDENCE: 0.7,
            PersonalityDimension.HUMOR: 0.2,
        },
        voice=VoiceCharacteristics(
            voice_id="professional_neutral",
            speaking_rate=1.0,
            pitch=0,
        ),
        communication=CommunicationStyle(
            sentence_length="medium",
            vocabulary_level="standard",
            uses_contractions=True,
            uses_filler_words=False,
            active_listening_phrases=[
                "I understand.",
                "Certainly.",
                "Of course.",
                "I can help with that."
            ]
        ),
        behavior=PersonaBehavior(
            greeting_style="professional",
            farewell_style="courteous",
            error_handling_style="solution-focused",
        ),
        preferred_phrases=[
            "I'd be happy to assist",
            "Let me help you with that",
            "I can certainly do that",
        ],
        avoided_phrases=[
            "No problem",
            "Sure thing",
            "Awesome",
            "Cool",
        ]
    ),

    "friendly_helper": VoicePersona(
        name="Sam",
        role="Friendly Customer Helper",
        description="A warm, approachable assistant for consumer interactions",
        personality={
            PersonalityDimension.WARMTH: 0.9,
            PersonalityDimension.FORMALITY: 0.3,
            PersonalityDimension.ENERGY: 0.7,
            PersonalityDimension.CONFIDENCE: 0.6,
            PersonalityDimension.HUMOR: 0.5,
        },
        voice=VoiceCharacteristics(
            voice_id="friendly_warm",
            speaking_rate=1.05,
            pitch=2,
        ),
        communication=CommunicationStyle(
            sentence_length="short",
            vocabulary_level="simple",
            uses_contractions=True,
            uses_filler_words=False,
            active_listening_phrases=[
                "Got it!",
                "I hear you.",
                "Absolutely!",
                "That makes sense."
            ]
        ),
        behavior=PersonaBehavior(
            greeting_style="enthusiastic",
            farewell_style="warm",
            error_handling_style="empathetic",
        ),
        preferred_phrases=[
            "Great question",
            "I'm here to help",
            "Let's get that sorted",
            "Happy to help",
        ],
        avoided_phrases=[
            "Per our policy",
            "Unfortunately",
            "I'm afraid",
            "Regrettably",
        ]
    ),

    "expert_advisor": VoicePersona(
        name="Dr. Morgan",
        role="Expert Technical Advisor",
        description="A knowledgeable expert for technical or specialized domains",
        personality={
            PersonalityDimension.WARMTH: 0.5,
            PersonalityDimension.FORMALITY: 0.6,
            PersonalityDimension.ENERGY: 0.4,
            PersonalityDimension.CONFIDENCE: 0.9,
            PersonalityDimension.HUMOR: 0.1,
        },
        voice=VoiceCharacteristics(
            voice_id="authoritative_calm",
            speaking_rate=0.95,
            pitch=-1,
        ),
        communication=CommunicationStyle(
            sentence_length="medium",
            vocabulary_level="sophisticated",
            uses_contractions=True,
            uses_filler_words=False,
            active_listening_phrases=[
                "That's a good question.",
                "Let me explain.",
                "Here's what I'd recommend.",
                "Based on my expertise."
            ]
        ),
        behavior=PersonaBehavior(
            greeting_style="confident",
            farewell_style="professional",
            error_handling_style="educational",
        )
    )
}
```

### Custom Persona Builder

```python
class PersonaBuilder:
    """Fluent builder for creating custom personas"""

    def __init__(self, name: str, role: str):
        self.persona = VoicePersona(
            name=name,
            role=role,
            description="",
            personality={},
            voice=VoiceCharacteristics(voice_id="default"),
            communication=CommunicationStyle(),
            behavior=PersonaBehavior()
        )

    def with_description(self, description: str) -> 'PersonaBuilder':
        self.persona.description = description
        return self

    def with_personality(
        self,
        warmth: float = 0.5,
        formality: float = 0.5,
        energy: float = 0.5,
        confidence: float = 0.5,
        humor: float = 0.5
    ) -> 'PersonaBuilder':
        self.persona.personality = {
            PersonalityDimension.WARMTH: warmth,
            PersonalityDimension.FORMALITY: formality,
            PersonalityDimension.ENERGY: energy,
            PersonalityDimension.CONFIDENCE: confidence,
            PersonalityDimension.HUMOR: humor,
        }
        return self

    def with_voice(
        self,
        voice_id: str,
        speaking_rate: float = 1.0,
        pitch: float = 0.0
    ) -> 'PersonaBuilder':
        self.persona.voice = VoiceCharacteristics(
            voice_id=voice_id,
            speaking_rate=speaking_rate,
            pitch=pitch
        )
        return self

    def prefers_phrases(self, phrases: List[str]) -> 'PersonaBuilder':
        self.persona.preferred_phrases = phrases
        return self

    def avoids_phrases(self, phrases: List[str]) -> 'PersonaBuilder':
        self.persona.avoided_phrases = phrases
        return self

    def with_domain_vocabulary(self, vocabulary: Dict[str, str]) -> 'PersonaBuilder':
        """Map generic terms to domain-specific terms"""
        self.persona.domain_vocabulary = vocabulary
        return self

    def build(self) -> VoicePersona:
        return self.persona

# Usage example
healthcare_assistant = (
    PersonaBuilder("Grace", "Healthcare Assistant")
    .with_description("A caring, knowledgeable healthcare support assistant")
    .with_personality(warmth=0.8, formality=0.5, energy=0.4, confidence=0.7, humor=0.1)
    .with_voice("caring_female", speaking_rate=0.95)
    .prefers_phrases([
        "I understand this can be concerning",
        "Let me help you find the right information",
        "Your health is important",
    ])
    .avoids_phrases([
        "You should",
        "You must",
        "This is your fault",
    ])
    .with_domain_vocabulary({
        "appointment": "visit",
        "doctor": "healthcare provider",
        "medicine": "medication",
    })
    .build()
)
```

## Maintaining Consistency

Consistency requires active enforcement across all response generation pathways.

### Persona Enforcement Layer

```python
class PersonaEnforcer:
    """Enforce persona consistency in responses"""

    def __init__(self, persona: VoicePersona):
        self.persona = persona
        self.phrase_replacements = self._build_phrase_replacements()

    def _build_phrase_replacements(self) -> Dict[str, str]:
        """Build replacement map from avoided to preferred phrases"""
        replacements = {}

        # Build semantic replacement pairs
        avoided_to_preferred = {
            # Formality adjustments
            "no problem": "you're welcome",
            "sure thing": "certainly",
            "awesome": "excellent",
            "cool": "great",
            "gonna": "going to",
            "wanna": "want to",
            "gotta": "need to",

            # Warmth adjustments
            "unfortunately": "I'm sorry, but",
            "I'm afraid": "I should mention that",
            "per our policy": "our guidelines suggest",
            "you must": "I'd recommend",
            "you should": "you might want to",
        }

        # Filter based on persona preferences
        for avoided, replacement in avoided_to_preferred.items():
            if avoided.lower() in [p.lower() for p in self.persona.avoided_phrases]:
                replacements[avoided] = replacement

        return replacements

    def enforce(self, response: str) -> str:
        """Apply persona enforcement to response"""

        # Replace avoided phrases
        response = self._replace_avoided_phrases(response)

        # Adjust formality
        response = self._adjust_formality(response)

        # Apply vocabulary
        response = self._apply_domain_vocabulary(response)

        # Enforce communication style
        response = self._enforce_communication_style(response)

        return response

    def _replace_avoided_phrases(self, text: str) -> str:
        """Replace avoided phrases with alternatives"""
        result = text

        for avoided in self.persona.avoided_phrases:
            if avoided.lower() in result.lower():
                # Find a suitable replacement
                replacement = self.phrase_replacements.get(
                    avoided.lower(),
                    self._get_default_replacement(avoided)
                )
                result = re.sub(
                    re.escape(avoided),
                    replacement,
                    result,
                    flags=re.IGNORECASE
                )

        return result

    def _get_default_replacement(self, avoided: str) -> str:
        """Get default replacement for an avoided phrase"""
        # Try to find semantically similar preferred phrase
        for preferred in self.persona.preferred_phrases:
            # Simple heuristic - more sophisticated in production
            if len(set(avoided.lower().split()) & set(preferred.lower().split())) > 0:
                return preferred

        return ""  # Remove if no replacement found

    def _adjust_formality(self, text: str) -> str:
        """Adjust formality based on persona"""
        formality = self.persona.personality.get(PersonalityDimension.FORMALITY, 0.5)

        if formality > 0.7:
            # Make more formal
            text = self._formalize(text)
        elif formality < 0.3:
            # Make more casual
            text = self._casualize(text)

        return text

    def _formalize(self, text: str) -> str:
        """Make text more formal"""
        contractions = {
            "i'm": "I am",
            "you're": "you are",
            "we're": "we are",
            "they're": "they are",
            "it's": "it is",
            "that's": "that is",
            "don't": "do not",
            "doesn't": "does not",
            "can't": "cannot",
            "won't": "will not",
            "wouldn't": "would not",
            "couldn't": "could not",
            "shouldn't": "should not",
            "i'll": "I will",
            "you'll": "you will",
            "we'll": "we will",
        }

        if not self.persona.communication.uses_contractions:
            return text  # Already handled by communication style

        for contraction, expansion in contractions.items():
            text = re.sub(rf"\b{contraction}\b", expansion, text, flags=re.IGNORECASE)

        return text

    def _casualize(self, text: str) -> str:
        """Make text more casual"""
        formal_to_casual = {
            "I am": "I'm",
            "you are": "you're",
            "we are": "we're",
            "it is": "it's",
            "do not": "don't",
            "does not": "doesn't",
            "cannot": "can't",
            "will not": "won't",
            "I will": "I'll",
            "you will": "you'll",
        }

        for formal, casual in formal_to_casual.items():
            text = re.sub(rf"\b{formal}\b", casual, text, flags=re.IGNORECASE)

        return text

    def _apply_domain_vocabulary(self, text: str) -> str:
        """Apply domain-specific vocabulary"""
        for generic, domain_specific in self.persona.domain_vocabulary.items():
            text = re.sub(
                rf"\b{generic}\b",
                domain_specific,
                text,
                flags=re.IGNORECASE
            )

        return text

    def _enforce_communication_style(self, text: str) -> str:
        """Enforce communication style preferences"""
        style = self.persona.communication

        # Handle contractions
        if not style.uses_contractions:
            text = self._formalize(text)

        # Handle sentence length
        if style.sentence_length == "short":
            text = self._shorten_sentences(text)
        elif style.sentence_length == "long":
            text = self._allow_longer_sentences(text)

        return text

    def _shorten_sentences(self, text: str) -> str:
        """Break long sentences into shorter ones"""
        sentences = re.split(r'(?<=[.!?])\s+', text)
        shortened = []

        for sentence in sentences:
            words = sentence.split()
            if len(words) > 20:
                # Try to break at conjunctions
                parts = re.split(r',\s*(?:and|but|or|so)\s*', sentence)
                if len(parts) > 1:
                    shortened.extend([p.strip() + '.' for p in parts if p.strip()])
                else:
                    shortened.append(sentence)
            else:
                shortened.append(sentence)

        return ' '.join(shortened)

    def _allow_longer_sentences(self, text: str) -> str:
        """Combine short sentences where appropriate"""
        # Implementation for combining short sentences
        return text
```

### Consistency Scoring

```python
class PersonaConsistencyScorer:
    """Score responses for persona consistency"""

    def __init__(self, persona: VoicePersona):
        self.persona = persona

    def score(self, response: str) -> Dict[str, float]:
        """Score response for persona consistency"""

        scores = {}

        # Vocabulary alignment
        scores['vocabulary'] = self._score_vocabulary(response)

        # Tone alignment
        scores['tone'] = self._score_tone(response)

        # Style alignment
        scores['style'] = self._score_style(response)

        # Avoided phrases check
        scores['avoided_phrases'] = self._score_avoided_phrases(response)

        # Overall score
        scores['overall'] = sum(scores.values()) / len(scores)

        return scores

    def _score_vocabulary(self, response: str) -> float:
        """Score vocabulary alignment"""
        score = 1.0

        # Check for preferred phrases
        preferred_found = 0
        for phrase in self.persona.preferred_phrases:
            if phrase.lower() in response.lower():
                preferred_found += 1

        # Bonus for using preferred phrases
        if self.persona.preferred_phrases:
            score += min(0.2, preferred_found * 0.05)

        # Check for domain vocabulary usage
        for generic, specific in self.persona.domain_vocabulary.items():
            if generic.lower() in response.lower() and specific.lower() not in response.lower():
                score -= 0.1

        return max(0, min(1, score))

    def _score_tone(self, response: str) -> float:
        """Score tone alignment with personality"""
        score = 1.0

        warmth = self.persona.personality.get(PersonalityDimension.WARMTH, 0.5)
        formality = self.persona.personality.get(PersonalityDimension.FORMALITY, 0.5)

        # Check warmth indicators
        warm_phrases = ["happy to", "glad to", "love to", "here to help"]
        cold_phrases = ["must", "required", "mandatory", "prohibited"]

        warm_count = sum(1 for p in warm_phrases if p in response.lower())
        cold_count = sum(1 for p in cold_phrases if p in response.lower())

        if warmth > 0.7 and cold_count > warm_count:
            score -= 0.2
        elif warmth < 0.3 and warm_count > cold_count:
            score -= 0.1

        # Check formality indicators
        contractions = ["i'm", "you're", "we're", "don't", "can't", "won't"]
        contraction_count = sum(1 for c in contractions if c in response.lower())

        if formality > 0.7 and contraction_count > 2:
            score -= 0.15
        elif formality < 0.3 and contraction_count == 0:
            score -= 0.1

        return max(0, min(1, score))

    def _score_style(self, response: str) -> float:
        """Score communication style alignment"""
        score = 1.0
        style = self.persona.communication

        # Check sentence length
        sentences = re.split(r'(?<=[.!?])\s+', response)
        avg_words = sum(len(s.split()) for s in sentences) / max(len(sentences), 1)

        if style.sentence_length == "short" and avg_words > 15:
            score -= 0.2
        elif style.sentence_length == "long" and avg_words < 8:
            score -= 0.1

        return max(0, min(1, score))

    def _score_avoided_phrases(self, response: str) -> float:
        """Check for avoided phrases"""
        score = 1.0

        for phrase in self.persona.avoided_phrases:
            if phrase.lower() in response.lower():
                score -= 0.2  # Significant penalty

        return max(0, score)

    def get_improvement_suggestions(
        self,
        response: str,
        scores: Dict[str, float]
    ) -> List[str]:
        """Get suggestions for improving consistency"""
        suggestions = []

        if scores['avoided_phrases'] < 1.0:
            avoided_found = [
                p for p in self.persona.avoided_phrases
                if p.lower() in response.lower()
            ]
            suggestions.append(f"Remove avoided phrases: {', '.join(avoided_found)}")

        if scores['tone'] < 0.8:
            warmth = self.persona.personality.get(PersonalityDimension.WARMTH, 0.5)
            if warmth > 0.7:
                suggestions.append("Add warmer language")
            elif warmth < 0.3:
                suggestions.append("Use more neutral language")

        if scores['vocabulary'] < 0.8:
            suggestions.append("Use domain-specific vocabulary")

        return suggestions
```

## Brand Voice Guidelines

Brand voice guidelines translate organizational identity into specific voice AI behaviors.

### Brand Voice Definition

```python
@dataclass
class BrandVoiceGuidelines:
    """Complete brand voice definition"""

    # Brand identity
    brand_name: str
    brand_values: List[str]
    brand_personality: str

    # Voice attributes
    voice_attributes: Dict[str, str]  # attribute -> description

    # Do's and Don'ts
    dos: List[str]
    donts: List[str]

    # Example phrases
    on_brand_examples: List[Dict[str, str]]  # situation -> response
    off_brand_examples: List[Dict[str, str]]

    # Emotional responses
    emotional_guidelines: Dict[str, str]  # emotion -> how to respond

    # Scenario-specific guidance
    scenario_guidelines: Dict[str, Dict[str, Any]]

    def to_prompt(self) -> str:
        """Convert to LLM system prompt"""
        prompt = f"""You are the voice of {self.brand_name}.

BRAND PERSONALITY: {self.brand_personality}

BRAND VALUES: {', '.join(self.brand_values)}

VOICE ATTRIBUTES:
"""
        for attr, desc in self.voice_attributes.items():
            prompt += f"- {attr}: {desc}\n"

        prompt += "\nALWAYS:\n"
        for do in self.dos:
            prompt += f"- {do}\n"

        prompt += "\nNEVER:\n"
        for dont in self.donts:
            prompt += f"- {dont}\n"

        return prompt

# Example brand voice guidelines
SAMPLE_BRAND_GUIDELINES = BrandVoiceGuidelines(
    brand_name="TechFlow",
    brand_values=["Innovation", "Simplicity", "Customer Success"],
    brand_personality="Confident, helpful, and approachable expert",

    voice_attributes={
        "Tone": "Friendly but professional, never condescending",
        "Language": "Clear and jargon-free, technical terms explained simply",
        "Pacing": "Efficient but never rushed, respect the customer's time",
        "Empathy": "Acknowledge frustrations, focus on solutions",
    },

    dos=[
        "Use active voice and direct language",
        "Acknowledge customer concerns before problem-solving",
        "Offer clear next steps",
        "Be honest about limitations",
        "Celebrate customer successes",
        "Use inclusive language",
    ],

    donts=[
        "Use passive-aggressive language",
        "Blame the customer for issues",
        "Over-promise on timelines",
        "Use excessive jargon or acronyms",
        "Sound robotic or scripted",
        "Dismiss customer concerns",
    ],

    on_brand_examples=[
        {
            "situation": "Customer can't log in",
            "response": "I'm sorry you're having trouble logging in. Let's fix this together. Can you tell me what happens when you try to sign in?"
        },
        {
            "situation": "Feature request",
            "response": "That's a great idea! I'll make sure our product team sees this feedback. In the meantime, here's how you might accomplish something similar..."
        },
    ],

    off_brand_examples=[
        {
            "situation": "Customer can't log in",
            "bad_response": "Have you tried turning it off and on again? It's probably user error.",
            "why_bad": "Condescending, blames customer, not empathetic"
        },
    ],

    emotional_guidelines={
        "frustrated": "Acknowledge the frustration first, then pivot to solutions. Use phrases like 'I understand this is frustrating' or 'I can see why that would be annoying'",
        "confused": "Reassure them it's not their fault, offer to explain step by step",
        "happy": "Match their energy, celebrate with them",
        "urgent": "Convey understanding of urgency, be efficient but thorough",
    },

    scenario_guidelines={
        "escalation": {
            "approach": "Warm handoff with context",
            "phrases": ["Let me connect you with someone who can help further", "I want to make sure you get the best help possible"],
            "never_say": ["That's above my pay grade", "I can't help with that"]
        },
        "outage": {
            "approach": "Honest, apologetic, informative",
            "phrases": ["We're experiencing an issue right now", "Our team is actively working on this"],
            "never_say": ["Everything's fine", "That's weird, it works for me"]
        }
    }
)
```

### Brand Voice Validator

```python
class BrandVoiceValidator:
    """Validate responses against brand guidelines"""

    def __init__(self, guidelines: BrandVoiceGuidelines):
        self.guidelines = guidelines

    def validate(self, response: str, context: Dict = None) -> Dict:
        """Validate response against brand voice"""

        issues = []
        score = 1.0

        # Check don'ts
        for dont in self.guidelines.donts:
            if self._violates_dont(response, dont):
                issues.append({
                    "type": "dont_violation",
                    "guideline": dont,
                    "severity": "high"
                })
                score -= 0.15

        # Check do's coverage
        dos_followed = self._check_dos(response, context)
        score += dos_followed * 0.1

        # Check emotional appropriateness
        if context and context.get("user_emotion"):
            emotion_check = self._check_emotional_response(
                response,
                context["user_emotion"]
            )
            if not emotion_check["appropriate"]:
                issues.append({
                    "type": "emotional_mismatch",
                    "expected": emotion_check["expected"],
                    "severity": "medium"
                })
                score -= 0.1

        # Check voice attributes
        attribute_score = self._check_voice_attributes(response)
        score = score * 0.7 + attribute_score * 0.3

        return {
            "valid": score >= 0.7,
            "score": max(0, min(1, score)),
            "issues": issues,
            "suggestions": self._generate_suggestions(issues)
        }

    def _violates_dont(self, response: str, dont: str) -> bool:
        """Check if response violates a 'don't' guideline"""

        # Define patterns for common don'ts
        dont_patterns = {
            "passive-aggressive": [
                r"as i already said",
                r"like i told you",
                r"obviously",
                r"clearly you",
            ],
            "blame the customer": [
                r"you should have",
                r"you didn't",
                r"your fault",
                r"user error",
            ],
            "robotic": [
                r"thank you for your patience your call is important to us",
                r"please hold for the next available representative",
            ],
            "dismiss": [
                r"that's not a big deal",
                r"it's not that important",
                r"you're overreacting",
            ]
        }

        # Check relevant patterns
        for category, patterns in dont_patterns.items():
            if any(keyword in dont.lower() for keyword in category.split()):
                for pattern in patterns:
                    if re.search(pattern, response.lower()):
                        return True

        return False

    def _check_dos(self, response: str, context: Dict) -> float:
        """Check how well response follows 'do' guidelines"""
        followed = 0
        total = len(self.guidelines.dos)

        # Check each 'do'
        for do in self.guidelines.dos:
            if self._follows_do(response, do, context):
                followed += 1

        return followed / max(total, 1)

    def _follows_do(self, response: str, do: str, context: Dict) -> bool:
        """Check if response follows a specific 'do' guideline"""

        # Pattern matching for common dos
        if "active voice" in do.lower():
            # Check for passive voice indicators
            passive_indicators = ["was done", "were made", "has been", "have been"]
            return not any(p in response.lower() for p in passive_indicators)

        if "acknowledge" in do.lower() and context:
            if context.get("user_emotion") in ["frustrated", "upset", "confused"]:
                acknowledgment_phrases = [
                    "understand", "sorry", "apologize",
                    "frustrating", "hear you", "see why"
                ]
                return any(p in response.lower() for p in acknowledgment_phrases)

        if "clear next steps" in do.lower():
            action_phrases = ["let's", "i'll", "you can", "next", "here's how"]
            return any(p in response.lower() for p in action_phrases)

        return True  # Default to following if can't determine

    def _check_emotional_response(
        self,
        response: str,
        user_emotion: str
    ) -> Dict:
        """Check if response matches emotional guidelines"""

        guidelines = self.guidelines.emotional_guidelines.get(user_emotion, "")

        # Extract expected elements from guidelines
        expected_elements = []
        if "acknowledge" in guidelines.lower():
            expected_elements.append("acknowledgment")
        if "empathy" in guidelines.lower() or "understand" in guidelines.lower():
            expected_elements.append("empathy")
        if "solution" in guidelines.lower():
            expected_elements.append("solution-focus")

        # Check for expected elements
        found = []
        if any(w in response.lower() for w in ["understand", "sorry", "apologize", "hear"]):
            found.append("empathy")
        if any(w in response.lower() for w in ["let's", "can", "will", "here's"]):
            found.append("solution-focus")

        return {
            "appropriate": len(found) >= len(expected_elements) / 2,
            "expected": expected_elements,
            "found": found
        }

    def _check_voice_attributes(self, response: str) -> float:
        """Score alignment with voice attributes"""
        score = 1.0

        # Check tone
        if "friendly" in self.guidelines.voice_attributes.get("Tone", "").lower():
            friendly_indicators = ["happy to", "glad", "great", "thanks"]
            if not any(f in response.lower() for f in friendly_indicators):
                score -= 0.1

        # Check language complexity
        if "jargon-free" in self.guidelines.voice_attributes.get("Language", "").lower():
            # Simple readability check
            words = response.split()
            long_words = [w for w in words if len(w) > 10]
            if len(long_words) / max(len(words), 1) > 0.15:
                score -= 0.1

        return score

    def _generate_suggestions(self, issues: List[Dict]) -> List[str]:
        """Generate suggestions to fix issues"""
        suggestions = []

        for issue in issues:
            if issue["type"] == "dont_violation":
                suggestions.append(f"Revise to avoid: {issue['guideline']}")
            elif issue["type"] == "emotional_mismatch":
                suggestions.append(f"Add elements for emotional context: {issue['expected']}")

        return suggestions
```

## Personality Traits

Personality traits provide the building blocks for consistent persona behavior across varied situations.

### Trait-Based Response Adaptation

```python
class PersonalityTraitAdapter:
    """Adapt responses based on personality traits"""

    def __init__(self, persona: VoicePersona):
        self.persona = persona

    def adapt(self, base_response: str, situation: str = "general") -> str:
        """Adapt response based on personality traits"""

        response = base_response

        # Apply each personality dimension
        response = self._apply_warmth(response, situation)
        response = self._apply_formality(response, situation)
        response = self._apply_energy(response, situation)
        response = self._apply_confidence(response, situation)
        response = self._apply_humor(response, situation)

        return response

    def _apply_warmth(self, response: str, situation: str) -> str:
        """Apply warmth level to response"""
        warmth = self.persona.personality.get(PersonalityDimension.WARMTH, 0.5)

        if warmth > 0.7:
            # Add warm touches
            if not any(w in response.lower() for w in ["happy", "glad", "love"]):
                if situation == "greeting":
                    response = "Great to hear from you! " + response
                elif "help" in response.lower():
                    response = response.replace("I can help", "I'd be happy to help")

            # Add personal touches
            if not response.endswith("?"):
                response += " Is there anything else I can help you with?"

        elif warmth < 0.3:
            # More efficient, less effusive
            remove_phrases = ["I'd be happy to", "I'm glad to", "It's my pleasure to"]
            for phrase in remove_phrases:
                response = response.replace(phrase, "I'll")

        return response

    def _apply_formality(self, response: str, situation: str) -> str:
        """Apply formality level to response"""
        formality = self.persona.personality.get(PersonalityDimension.FORMALITY, 0.5)

        if formality > 0.7:
            # Formal adjustments
            casual_to_formal = {
                "Hi": "Hello",
                "Hey": "Hello",
                "Thanks": "Thank you",
                "Bye": "Goodbye",
                "OK": "Certainly",
                "Sure": "Of course",
                "Yeah": "Yes",
                "Nope": "No",
            }

            for casual, formal in casual_to_formal.items():
                response = re.sub(rf"\b{casual}\b", formal, response, flags=re.IGNORECASE)

        elif formality < 0.3:
            # Casual adjustments
            formal_to_casual = {
                "Hello": "Hi",
                "Goodbye": "Bye",
                "Thank you": "Thanks",
                "Certainly": "Sure",
                "Of course": "Absolutely",
            }

            for formal, casual in formal_to_casual.items():
                response = re.sub(rf"\b{formal}\b", casual, response, flags=re.IGNORECASE)

        return response

    def _apply_energy(self, response: str, situation: str) -> str:
        """Apply energy level to response"""
        energy = self.persona.personality.get(PersonalityDimension.ENERGY, 0.5)

        if energy > 0.7:
            # Add enthusiasm
            neutral_to_enthusiastic = {
                "Good": "Great",
                "good": "great",
                "Okay": "Perfect",
                "Fine": "Wonderful",
                "nice": "fantastic",
            }

            for neutral, enthusiastic in neutral_to_enthusiastic.items():
                response = response.replace(neutral, enthusiastic)

            # Add exclamation for appropriate sentences
            sentences = response.split('. ')
            enhanced = []
            for s in sentences:
                if any(w in s.lower() for w in ["great", "wonderful", "perfect", "fantastic"]):
                    if not s.endswith('!'):
                        s = s.rstrip('.') + '!'
                enhanced.append(s)
            response = '. '.join(enhanced)

        elif energy < 0.3:
            # More calm and measured
            enthusiastic_to_calm = {
                "!": ".",
                "Great!": "Good.",
                "Wonderful!": "Good.",
                "Fantastic!": "Good.",
                "Amazing!": "Good.",
            }

            for enthusiastic, calm in enthusiastic_to_calm.items():
                response = response.replace(enthusiastic, calm)

        return response

    def _apply_confidence(self, response: str, situation: str) -> str:
        """Apply confidence level to response"""
        confidence = self.persona.personality.get(PersonalityDimension.CONFIDENCE, 0.5)

        if confidence > 0.7:
            # Assertive language
            hedging_removal = {
                "I think": "",
                "maybe": "",
                "possibly": "",
                "I believe": "",
                "might be": "is",
                "could be": "is",
                "should work": "will work",
            }

            for hedge, replacement in hedging_removal.items():
                response = response.replace(hedge, replacement)

            # Clean up extra spaces
            response = ' '.join(response.split())

        elif confidence < 0.3:
            # More humble language
            assertive_to_humble = {
                "You should": "You might want to",
                "You need to": "It might help to",
                "This will": "This should",
                "I will": "I'll try to",
            }

            for assertive, humble in assertive_to_humble.items():
                response = re.sub(rf"\b{assertive}\b", humble, response, flags=re.IGNORECASE)

        return response

    def _apply_humor(self, response: str, situation: str) -> str:
        """Apply humor level (carefully) to response"""
        humor = self.persona.personality.get(PersonalityDimension.HUMOR, 0.5)

        # Humor in voice AI is tricky - apply sparingly
        if humor > 0.7 and situation in ["greeting", "farewell", "success"]:
            # Light touches only
            if situation == "success" and "done" in response.lower():
                response = response.replace("done", "done and dusted")

        elif humor < 0.2:
            # Remove any playful language
            playful_phrases = ["ta-da", "voila", "easy peasy", "piece of cake"]
            for phrase in playful_phrases:
                response = response.replace(phrase, "complete")

        return response
```

### Situational Trait Adjustment

```python
class SituationalTraitAdjuster:
    """Adjust personality traits based on situation"""

    def __init__(self, base_persona: VoicePersona):
        self.base_persona = base_persona

        # Situational adjustments
        self.adjustments = {
            "error": {
                PersonalityDimension.WARMTH: 0.1,      # Be warmer
                PersonalityDimension.HUMOR: -0.3,      # Less humor
                PersonalityDimension.CONFIDENCE: -0.1, # Slightly more humble
            },
            "complaint": {
                PersonalityDimension.WARMTH: 0.2,
                PersonalityDimension.ENERGY: -0.2,     # Calmer
                PersonalityDimension.HUMOR: -0.4,
            },
            "success": {
                PersonalityDimension.WARMTH: 0.1,
                PersonalityDimension.ENERGY: 0.15,
                PersonalityDimension.HUMOR: 0.1,
            },
            "technical_explanation": {
                PersonalityDimension.FORMALITY: 0.1,
                PersonalityDimension.CONFIDENCE: 0.15,
                PersonalityDimension.HUMOR: -0.2,
            },
            "escalation": {
                PersonalityDimension.WARMTH: 0.15,
                PersonalityDimension.FORMALITY: 0.1,
                PersonalityDimension.ENERGY: -0.1,
            }
        }

    def get_adjusted_persona(self, situation: str) -> VoicePersona:
        """Get persona adjusted for situation"""

        import copy
        adjusted = copy.deepcopy(self.base_persona)

        if situation in self.adjustments:
            for dimension, adjustment in self.adjustments[situation].items():
                base_value = adjusted.personality.get(dimension, 0.5)
                adjusted.personality[dimension] = max(0, min(1, base_value + adjustment))

        return adjusted

    def describe_adjustment(self, situation: str) -> str:
        """Describe how persona adjusts for situation"""

        if situation not in self.adjustments:
            return "No adjustment needed for this situation."

        descriptions = []
        for dimension, adjustment in self.adjustments[situation].items():
            direction = "more" if adjustment > 0 else "less"
            trait = dimension.value.replace("_", " ")
            descriptions.append(f"{direction} {trait}")

        return f"For {situation}, the assistant becomes: {', '.join(descriptions)}."
```

## Complete Integration Example

```python
class PersonaConsistentVoiceAgent:
    """Voice agent with full persona consistency"""

    def __init__(
        self,
        persona: VoicePersona,
        brand_guidelines: BrandVoiceGuidelines,
        llm_provider
    ):
        self.persona = persona
        self.guidelines = brand_guidelines

        # Initialize components
        self.enforcer = PersonaEnforcer(persona)
        self.scorer = PersonaConsistencyScorer(persona)
        self.brand_validator = BrandVoiceValidator(brand_guidelines)
        self.trait_adapter = PersonalityTraitAdapter(persona)
        self.situational_adjuster = SituationalTraitAdjuster(persona)

        self.llm = llm_provider

    def generate_response(
        self,
        user_input: str,
        context: Dict[str, Any]
    ) -> Dict:
        """Generate persona-consistent response"""

        # Determine situation
        situation = self._detect_situation(user_input, context)

        # Get situationally-adjusted persona
        adjusted_persona = self.situational_adjuster.get_adjusted_persona(situation)

        # Build persona-aware prompt
        system_prompt = self._build_system_prompt(adjusted_persona)

        # Generate base response
        base_response = self.llm.generate(
            user_input,
            context,
            system_prompt=system_prompt
        )

        # Apply trait adaptations
        adapted_response = self.trait_adapter.adapt(base_response, situation)

        # Enforce persona constraints
        enforced_response = self.enforcer.enforce(adapted_response)

        # Validate against brand guidelines
        brand_validation = self.brand_validator.validate(
            enforced_response,
            {"user_emotion": context.get("detected_emotion"), "situation": situation}
        )

        # Score consistency
        consistency_score = self.scorer.score(enforced_response)

        # Re-generate if quality is too low
        if consistency_score["overall"] < 0.6 or not brand_validation["valid"]:
            enforced_response = self._regenerate_with_guidance(
                user_input,
                context,
                consistency_score,
                brand_validation
            )

        return {
            "response": enforced_response,
            "situation": situation,
            "consistency_score": consistency_score["overall"],
            "brand_compliance": brand_validation["valid"],
            "persona_name": self.persona.name
        }

    def _detect_situation(self, user_input: str, context: Dict) -> str:
        """Detect the current situation type"""

        input_lower = user_input.lower()

        if context.get("error_count", 0) > 0:
            return "error"
        if any(w in input_lower for w in ["frustrated", "angry", "upset", "disappointed"]):
            return "complaint"
        if any(w in input_lower for w in ["thank", "great", "perfect", "awesome"]):
            return "success"
        if any(w in input_lower for w in ["how does", "explain", "what is"]):
            return "technical_explanation"
        if any(w in input_lower for w in ["speak to", "transfer", "manager", "supervisor"]):
            return "escalation"

        return "general"

    def _build_system_prompt(self, persona: VoicePersona) -> str:
        """Build system prompt incorporating persona"""

        prompt = f"""You are {persona.name}, {persona.role}.

{persona.description}

Your personality: {persona.get_personality_description()}

COMMUNICATION STYLE:
- Sentence length: {persona.communication.sentence_length}
- Vocabulary: {persona.communication.vocabulary_level}
- {"Use contractions" if persona.communication.uses_contractions else "Avoid contractions"}

PREFERRED PHRASES: {', '.join(persona.preferred_phrases[:5])}

NEVER SAY: {', '.join(persona.avoided_phrases[:5])}

{self.guidelines.to_prompt()}

Remember: You ARE {persona.name}. Stay in character at all times.
"""
        return prompt

    def _regenerate_with_guidance(
        self,
        user_input: str,
        context: Dict,
        consistency_score: Dict,
        brand_validation: Dict
    ) -> str:
        """Regenerate with specific guidance to improve quality"""

        issues = []
        if consistency_score["overall"] < 0.7:
            issues.extend(self.scorer.get_improvement_suggestions(
                "", consistency_score
            ))
        if not brand_validation["valid"]:
            issues.extend(brand_validation["suggestions"])

        guidance = f"IMPORTANT: Improve response by: {'; '.join(issues)}"

        # Regenerate with guidance
        # Implementation would call LLM again with additional guidance
        pass
```

## Next Steps

- **[Response Templates](/topics/foundations/language-generation/response-templates)** - Template-based responses
- **[Dynamic Generation](/topics/foundations/language-generation/dynamic-generation)** - LLM-based generation
- **[SSML](/topics/foundations/speech-synthesis/ssml)** - Speech synthesis markup for voice control
